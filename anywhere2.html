<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Places to See</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #map { height: 70vh; width: 100%; }
        #controls { padding: 10px; text-align: center; }
        select { padding: 5px; font-size: 16px; }
        h1 { text-align: center; margin: 10px 0; }
        @media (max-width: 600px) {
            #map { height: 60vh; }
            select { width: 100%; }
        }
    </style>
</head>
<body>
    <h1 id="map-title">Places to See</h1>
    <div id="controls">
        <select id="place-type" onchange="updatePlaces()">
            <option value="bar">Bar</option>
            <option value="cafe">Cafe</option>
            <option value="hotel">Hotel</option>
        </select>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let mygps = null;
        let cityname = "Unknown";
        let city = null;
        let dropdown = "bar";
        let places = [];
        let map = null;

        // Haversine formula to calculate distance in miles
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3958.8; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Initialize map
        function initMap(lat, lon) {
            map = L.map('map').setView([lat, lon], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
        }

        // Add marker with label
        function addMarker(lat, lon, label, isUser = false) {
            const marker = L.marker([lat, lon]).addTo(map);
            marker.bindPopup(label).openPopup();
            if (isUser) {
                marker.setZIndexOffset(1000); // Ensure user marker is on top
            }
        }

        // Get user's GPS coordinates
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        mygps = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude
                        };
                        initMap(mygps.lat, mygps.lon);
                        getNearestCity();
                    },
                    error => {
                        console.error("Geolocation error:", error);
                        alert("Unable to get your location. Using default coordinates.");
                        mygps = { lat: 51.505, lon: -0.09 }; // Default to London
                        initMap(mygps.lat, mygps.lon);
                        getNearestCity();
                    }
                );
            } else {
                alert("Geolocation is not supported by this browser.");
                mygps = { lat: 51.505, lon: -0.09 };
                initMap(mygps.lat, mygps.lon);
                getNearestCity();
            }
        }

        // Get nearest city using Nominatim
        async function getNearestCity() {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${mygps.lat}&lon=${mygps.lon}&zoom=10&addressdetails=1`,
                    { headers: { 'User-Agent': 'GrokPlacesApp/1.0' } }
                );
                const data = await response.json();
                cityname = data.address.city || data.address.town || data.address.village || "Unknown";
                city = {
                    lat: parseFloat(data.lat),
                    lon: parseFloat(data.lon)
                };
                document.getElementById('map-title').textContent = `Places to See in ${cityname}`;
                const distance = calculateDistance(mygps.lat, mygps.lon, city.lat, city.lon).toFixed(2);
                addMarker(mygps.lat, mygps.lon, `Your Location<br>${distance} miles from ${cityname}`, true);
                translateDropdown();
                updatePlaces();
            } catch (error) {
                console.error("Error fetching city:", error);
                cityname = "Unknown";
                city = mygps;
                document.getElementById('map-title').textContent = `Places to See in ${cityname}`;
                addMarker(mygps.lat, mygps.lon, `Your Location`, true);
                translateDropdown();
                updatePlaces();
            }
        }

        // Translate dropdown based on country
        async function translateDropdown() {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${mygps.lat}&lon=${mygps.lon}&addressdetails=1`,
                    { headers: { 'User-Agent': 'GrokPlacesApp/1.0' } }
                );
                const data = await response.json();
                const countryCode = data.address.country_code?.toUpperCase();
                const translations = {
                    FR: { bar: "Bar", cafe: "Café", hotel: "Hôtel" },
                    ES: { bar: "Bar", cafe: "Cafetería", hotel: "Hotel" },
                    DE: { bar: "Bar", cafe: "Café", hotel: "Hotel" },
                    IT: { bar: "Bar", cafe: "Caffè", hotel: "Hotel" }
                    // Add more as needed
                };
                const options = translations[countryCode] || { bar: "Bar", cafe: "Cafe", hotel: "Hotel" };
                const select = document.getElementById('place-type');
                select.innerHTML = `
                    <option value="bar">${options.bar}</option>
                    <option value="cafe">${options.cafe}</option>
                    <option value="hotel">${options.hotel}</option>
                `;
            } catch (error) {
                console.error("Error translating dropdown:", error);
            }
        }

        // Update places based on dropdown selection
        async function updatePlaces() {
            dropdown = document.getElementById('place-type').value;
            places = [];
            try {
                // Clear existing place markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer !== map.getCenter()) {
                        map.removeLayer(layer);
                    }
                });

                // Query Overpass API
                const query = `
                    [out:json];
                    node(around:10000,${mygps.lat},${mygps.lon})["amenity"="${dropdown}"];
                    out body 8;
                `;
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query,
                    headers: { 'User-Agent': 'GrokPlacesApp/1.0' }
                });
                const data = await response.json();

                places = data.elements.map(element => ({
                    name: element.tags.name || dropdown.charAt(0).toUpperCase() + dropdown.slice(1),
                    lat: element.lat,
                    lon: element.lon,
                    distance: calculateDistance(mygps.lat, mygps.lon, element.lat, element.lon).toFixed(2)
                }));

                // Sort by distance
                places.sort((a, b) => a.distance - b.distance);

                // Add markers for places
                places.forEach(place => {
                    addMarker(place.lat, place.lon, `${place.name}<br>${place.distance} miles from you`);
                });

                // Adjust map bounds to include all markers
                if (places.length > 0) {
                    const bounds = L.latLngBounds([
                        [mygps.lat, mygps.lon],
                        ...places.map(p => [p.lat, p.lon])
                    ]);
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            } catch (error) {
                console.error("Error fetching places:", error);
                alert("Unable to fetch nearby places. Please try again.");
            }
        }

        // Initialize
        getUserLocation();
    </script>
</body>
</html>