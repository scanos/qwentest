<!DOCTYPE html>
<html>
<head>
    <title>Image Geolocation Map</title>
    <meta charset="utf-8">
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .thumbnail {
            max-width: 100px;
            max-height: 100px;
        }
    </style>
    <script src="exif.js"></script>
</head>
<body>
    <h1>Image Geolocation Information</h1>

    <!-- Table for Image Metadata -->
    <h2>Image Metadata</h2>
    <table id="metadataTable">
        <tr>
            <th>Image Name</th>
            <th>Thumbnail</th>
            <th>Geolocation</th>
        </tr>
    </table>

    <!-- Table for Reverse Geocoding and Directions -->
    <h2>Locations and Walking Directions</h2>
    <table id="directionsTable">
        <tr>
            <th>Image</th>
            <th>Address</th>
            <th>Walking Directions</th>
        </tr>
    </table>

    <!-- Map Container -->
    <div id="map"></div>

    <script>
        const imageArray = ['h1.jpg', 'h2.jpg', 'h3.jpg', 'h4.jpg'];
        const apiKey = 'AIzaSyB2RYFaiLK0eKC3AZlcI45YmcJ7wfEBuiw'; // Replace with your API key
        let locations = [];
        
        // Function to convert DMS to Decimal Degrees
        function dmsToDecimal(degrees, minutes, seconds, direction) {
            let dd = degrees + minutes/60 + seconds/3600;
            if (direction === 'S' || direction === 'W') dd = -dd;
            return dd;
        }

        // Process images and build metadata table
        async function processImages() {
            const metadataTable = document.getElementById('metadataTable');
            
            for (let imgName of imageArray) {
                const row = metadataTable.insertRow();
                const cell1 = row.insertCell(0);
                const cell2 = row.insertCell(1);
                const cell3 = row.insertCell(2);
                
                cell1.textContent = imgName;
                
                const img = new Image();
                img.src = imgName;
                img.className = 'thumbnail';
                cell2.appendChild(img);

                try {
                    await new Promise((resolve) => {
                        EXIF.getData(img, function() {
                            const lat = EXIF.getTag(this, 'GPSLatitude');
                            const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
                            const lon = EXIF.getTag(this, 'GPSLongitude');
                            const lonRef = EXIF.getTag(this, 'GPSLongitudeRef');

                            if (lat && lon) {
                                const latDecimal = dmsToDecimal(lat[0], lat[1], lat[2], latRef);
                                const lonDecimal = dmsToDecimal(lon[0], lon[1], lon[2], lonRef);
                                cell3.textContent = `${latDecimal.toFixed(6)}, ${lonDecimal.toFixed(6)}`;
                                locations.push({
                                    name: imgName,
                                    lat: latDecimal,
                                    lng: lonDecimal,
                                    img: imgName
                                });
                            } else {
                                cell3.textContent = 'No geolocation data';
                            }
                            resolve();
                        });
                    });
                } catch (error) {
                    cell3.textContent = 'Error reading metadata';
                    console.error(error);
                }
            }
            await processLocations();
        }

        // Process locations with reverse geocoding and directions
        async function processLocations() {
            const directionsTable = document.getElementById('directionsTable');
            const geocoder = new google.maps.Geocoder();
            const directionsService = new google.maps.DirectionsService();

            // Reverse geocode each location
            for (let i = 0; i < locations.length; i++) {
                const row = directionsTable.insertRow();
                row.insertCell(0).textContent = locations[i].name;

                try {
                    const address = await reverseGeocode(geocoder, locations[i]);
                    row.insertCell(1).textContent = address || 'Unable to geocode';

                    if (i > 0) {
                        const directions = await getWalkingDirections(
                            directionsService,
                            locations[i-1],
                            locations[i]
                        );
                        row.insertCell(2).textContent = directions || 'No directions available';
                    } else {
                        row.insertCell(2).textContent = 'Starting point';
                    }
                } catch (error) {
                    console.error(error);
                }
            }
        }

        // Reverse geocode helper function
        function reverseGeocode(geocoder, location) {
            return new Promise((resolve) => {
                geocoder.geocode({ location: { lat: location.lat, lng: location.lng } }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        resolve(results[0].formatted_address);
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        // Get walking directions helper function
        function getWalkingDirections(directionsService, origin, destination) {
            return new Promise((resolve) => {
                directionsService.route({
                    origin: { lat: origin.lat, lng: origin.lng },
                    destination: { lat: destination.lat, lng: destination.lng },
                    travelMode: google.maps.TravelMode.WALKING
                }, (result, status) => {
                    if (status === 'OK') {
                        resolve(result.routes[0].legs[0].distance.text + ' - ' + 
                               result.routes[0].legs[0].duration.text);
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        // Initialize map
        function initMap() {
            if (!locations.length) return;

            const map = new google.maps.Map(document.getElementById('map'), {
                zoom: 15,
                center: { lat: locations[0].lat, lng: locations[0].lng },
                mapTypeId: google.maps.MapTypeId.ROADMAP
            });

            // Add markers
            locations.forEach(location => {
                const marker = new google.maps.Marker({
                    position: { lat: location.lat, lng: location.lng },
                    map: map,
                    title: location.name
                });

                const infoWindow = new google.maps.InfoWindow({
                    content: `<div>
                        <h3>${location.name}</h3>
                        <img src="${location.img}" class="thumbnail">
                    </div>`
                });

                marker.addListener('click', () => {
                    infoWindow.open(map, marker);
                });
            });
        }

        // Start processing
        processImages();
    </script>

 <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB2RYFaiLK0eKC3AZlcI45YmcJ7wfEBuiw&callback=initMap" async defer></script>
</body>
</html>
