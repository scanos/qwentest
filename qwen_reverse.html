<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Walking Route Plan</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  #map { height: 500px; width: 100%; }
  table { width: 100%; border-collapse: collapse; margin-top: 20px; }
  th, td { border: 1px solid black; padding: 8px; text-align: center; }
</style>
</head>
<body>
<div id="map"></div>
<table>
  <thead>
    <tr>
      <th>From</th>
      <th>To</th>
      <th>Distance (m)</th>
      <th>Time (min)</th>
    </tr>
  </thead>
  <tbody id="routeTableBody"></tbody>
  <tfoot>
    <tr>
      <td colspan="2"><strong>Total</strong></td>
      <td id="totalDistance"></td>
      <td id="totalTime"></td>
    </tr>
  </tfoot>
</table>

<script>
  const latLngArray = [
    [33.89462777777778, 35.51548611111111],
    [33.88783333333333, 35.515369444444445],
    [33.89488333333333, 35.51550833333334],
    [33.89487222222222, 35.515525]
  ];

  const map = L.map('map').setView(latLngArray[0], 16);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  const markers = [];
  const routeInstructions = [];

  // Function to reverse geocode
  async function reverseGeocode(lat, lon) {
    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`);
    const data = await response.json();
    return data.display_name;
  }

  // Function to calculate walking directions
  async function getWalkingDirections(from, to) {
    const response = await fetch(`https://routing.openstreetmap.de/routed-foot/route/v1/driving/${from[1]},${from[0]};${to[1]},${to[0]}?overview=false&steps=true`);
    const data = await response.json();
    const distance = Math.round(data.routes[0].distance);
    const duration = Math.round(data.routes[0].duration / 60); // Convert seconds to minutes
    return { distance, duration };
  }

  // Add markers and get location names
  Promise.all(latLngArray.map(async (latLng, index) => {
    const locationName = await reverseGeocode(latLng[0], latLng[1]);
    const marker = L.marker(latLng).addTo(map).bindPopup(locationName).openPopup();
    markers.push({ marker, locationName });
  })).then(() => {
    // Calculate routes and populate table
    let cumulativeDistance = 0;
    let cumulativeTime = 0;

    for (let i = 0; i < markers.length - 1; i++) {
      const from = markers[i];
      const to = markers[i + 1];

      getWalkingDirections(from.marker.getLatLng(), to.marker.getLatLng()).then(directions => {
        const distance = directions.distance;
        const duration = directions.duration;

        cumulativeDistance += distance;
        cumulativeTime += duration;

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${from.locationName}</td>
          <td>${to.locationName}</td>
          <td>${distance}</td>
          <td>${duration}</td>
        `;
        document.getElementById('routeTableBody').appendChild(row);

        if (i === markers.length - 2) {
          document.getElementById('totalDistance').textContent = cumulativeDistance;
          document.getElementById('totalTime').textContent = cumulativeTime;
        }
      });
    }
  });

  // Draw polyline for the route
  const polyline = L.polyline(latLngArray, { color: 'blue' }).addTo(map);
  map.fitBounds(polyline.getBounds());
</script>
</body>
</html>