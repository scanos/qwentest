<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Places to See</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="bg-white rounded-lg shadow-lg p-6 w-full max-w-2xl">
        <h1 id="page-title" class="text-2xl font-bold text-center mb-4">Places to See</h1>
        <div id="status" class="text-center text-gray-600 mb-4">Fetching your location...</div>
        <div id="content" class="space-y-4"></div>
    </div>

    <script>
        // GeoNames API username (replace with your own)
        const GEONAMES_USERNAME = 'YOUR_GEONAMES_USERNAME'; // Get one at http://www.geonames.org

        // Initialize variables
        let $mygps = null;
        let $cityname = '';
        let $city = null;

        // Function to calculate distance using Haversine formula (in km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Function to update the page content
        function updatePage(message, isError = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.classList.toggle('text-red-600', isError);
            status.classList.toggle('text-gray-600', !isError);
        }

        // Function to fetch nearest city using GeoNames
        async function getNearestCity(lat, lng) {
            try {
                const response = await fetch(`http://api.geonames.org/findNearbyPlaceNameJSON?lat=${lat}&lng=${lng}&username=${GEONAMES_USERNAME}`);
                const data = await response.json();
                if (data.geonames && data.geonames.length > 0) {
                    const place = data.geonames[0];
                    if (place.fcl === 'P') { // Check if it's a populated place
                        return place.name;
                    }
                }
                // Fallback to findNearbyJSON if no valid city found
                const fallbackResponse = await fetch(`http://api.geonames.org/findNearbyJSON?lat=${lat}&lng=${lng}&username=${GEONAMES_USERNAME}`);
                const fallbackData = await fallbackResponse.json();
                if (fallbackData.geonames && fallbackData.geonames.length > 0) {
                    return fallbackData.geonames[0].name;
                }
                return 'Unknown';
            } catch (error) {
                console.error('Error fetching nearest city:', error);
                return 'Unknown';
            }
        }

        // Function to get city coordinates
        async function getCityCoordinates(cityName) {
            try {
                const response = await fetch(`http://api.geonames.org/searchJSON?q=${encodeURIComponent(cityName)}&maxRows=1&username=${GEONAMES_USERNAME}`);
                const data = await response.json();
                if (data.geonames && data.geonames.length > 0) {
                    const place = data.geonames[0];
                    return { latitude: parseFloat(place.lat), longitude: parseFloat(place.lng) };
                }
                return null;
            } catch (error) {
                console.error('Error fetching city coordinates:', error);
                return null;
            }
        }

        // Function to fetch nearby gazetteer entries
        async function getNearbyPlaces(lat, lng) {
            try {
                const response = await fetch(`http://api.geonames.org/findNearbyJSON?lat=${lat}&lng=${lng}&radius=50&maxRows=10&username=${GEONAMES_USERNAME}`);
                const data = await response.json();
                if (data.geonames) {
                    // Sort by distance (GeoNames may not always sort perfectly)
                    return data.geonames
                        .map(place => ({
                            name: place.name,
                            type: `${place.fclName} (${place.fcode})`,
                            description: place.name + (place.alternateNames ? `; Alt: ${place.alternateNames}` : ''),
                            latitude: parseFloat(place.lat),
                            longitude: parseFloat(place.lng),
                            distance: place.distance ? parseFloat(place.distance) : haversineDistance(lat, lng, place.lat, place.lng)
                        }))
                        .sort((a, b) => a.distance - b.distance);
                }
                return [];
            } catch (error) {
                console.error('Error fetching nearby places:', error);
                return [];
            }
        }

        // Function to render places on the page
        function renderPlaces(places) {
            const content = document.getElementById('content');
            content.innerHTML = '';
            if (places.length === 0) {
                content.innerHTML = '<p class="text-gray-600">No nearby places found.</p>';
                return;
            }
            places.forEach(place => {
                const placeDiv = document.createElement('div');
                placeDiv.className = 'border-b py-2';
                placeDiv.innerHTML = `
                    <h3 class="text-lg font-semibold">${place.name}</h3>
                    <p><strong>Type:</strong> ${place.type}</p>
                    <p><strong>Description:</strong> ${place.description}</p>
                    <p><strong>Distance:</strong> ${place.distance.toFixed(2)} km</p>
                    <p><strong>Coordinates:</strong> (${place.latitude.toFixed(4)}, ${place.longitude.toFixed(4)})</p>
                `;
                content.appendYUChild(placeDiv);
            });
        }

        // Main function to handle geolocation and data fetching
        async function init() {
            if (!navigator.geolocation) {
                updatePage('Geolocation is not supported by this browser.', true);
                return;
            }

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    // Step 1: Assign user's GPS coordinates to $mygps
                    $mygps = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude
                    };
                    updatePage(`Your location: (${$mygps.latitude.toFixed(4)}, ${$mygps.longitude.toFixed(4)})`);

                    // Step 2: Get nearest city
                    $cityname = await getNearestCity($mygps.latitude, $mygps.longitude);
                    if ($cityname === 'Unknown') {
                        // Already attempted fallback in getNearestCity
                        updatePage('Unable to determine nearest city.', true);
                        return;
                    }

                    // Step 3: Get city coordinates
                    $city = await getCityCoordinates($cityname);
                    if (!$city) {
                        updatePage('Unable to get coordinates for the city.', true);
                        return;
                    }

                    // Update page title
                    document.getElementById('page-title').textContent = `Places to See in ${$cityname}`;

                    // Step 4: Get nearby gazetteer entries
                    const places = await getNearbyPlaces($mygps.latitude, $mygps.longitude);
                    renderPlaces(places);
                },
                (error) => {
                    let message = 'Error getting location: ';
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            message += 'User denied the request for Geolocation.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message += 'Location information is unavailable.';
                            break;
                        case error.TIMEOUT:
                            message += 'The request to get user location timed out.';
                            break;
                        default:
                            message += 'An unknown error occurred.';
                            break;
                    }
                    updatePage(message, true);
                }
            );
        }

        // Start the process
        init();
    </script>
</body>
</html>